<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>GeraMapas</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_GeraMapas.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption empty">&nbsp;</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Copyright</th><td>Filipe Monteiro (a80229@alunos.uminho.pt)//Jo&#227;o Amaral (a80694@alunos.uminho.pt);</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr></table><p class="caption">GeraMapas</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Esta primeira de tr&#234;s tarefas permite a cria&#231;&#227;o de um tabuleiro de dimens&#227;o e variada jogabilidade
definida pelo utilizador. Usa fun&#231;&#245;es recursivas definidas por n&#243;s, mas tamb&#233;m algumas ja existentes
no Haskell.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:mapa">mapa</a> :: Int -&gt; Int -&gt; [String]</li><li class="src short"><a href="#v:auxMapa2">auxMapa2</a> :: [String] -&gt; [Int] -&gt; [String]</li><li class="src short"><a href="#v:ret_Esp_Mapa">ret_Esp_Mapa</a> :: [String] -&gt; [String]</li><li class="src short"><a href="#v:contagem">contagem</a> :: [Char] -&gt; Int</li><li class="src short"><a href="#v:linhas">linhas</a> :: Int -&gt; Int -&gt; [String]</li><li class="src short"><a href="#v:coordenadas">coordenadas</a> :: [String] -&gt; [String]</li><li class="src short"><a href="#v:auxB">auxB</a> :: [(Int, Int)] -&gt; [String]</li><li class="src short"><a href="#v:auxF">auxF</a> :: [(Int, Int)] -&gt; [String]</li><li class="src short"><a href="#v:linhaPower">linhaPower</a> :: Int -&gt; Char -&gt; [String] -&gt; [Int]</li><li class="src short"><a href="#v:contAux">contAux</a> :: Char -&gt; [Char] -&gt; Int</li><li class="src short"><a href="#v:colunaPower">colunaPower</a> :: Char -&gt; [String] -&gt; [Int]</li><li class="src short"><a href="#v:auxcoluna">auxcoluna</a> :: Int -&gt; Char -&gt; String -&gt; [Int]</li><li class="src short"><a href="#v:mapaDebug">mapaDebug</a> :: Int -&gt; Int -&gt; [String]</li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a name="v:mapa" class="def">mapa</a> :: Int -&gt; Int -&gt; [String]</p><div class="doc"><p>#  -&gt; representa pedra</p><p>?  -&gt; representa tijolo</p><p>'' -&gt; representa c&#233;lula vazia</p><p><code>+</code> representa bombs</p><p><code>!</code> representa flames</p><p>x-coluna y-linha</p><p>Para fim de testes, usemos putStr (unlines (mapa n s)) no GHCi para visualizar o resultado.</p></div></div><div class="top"><p class="src"><a name="v:auxMapa2" class="def">auxMapa2</a> :: [String] -&gt; [Int] -&gt; [String]</p><div class="doc"><p>A fun&#231;&#227;o <strong>auxMapa2</strong> serve de auxiliar &#225; fun&#231;&#227;o <strong>coordenadas</strong>
Esta coloca os valores da lista Random no mapa.</p><ol><li><em>rnd</em> ser&#225; a lista dos numeros random</li><li>fazemos <strong>insEsp x</strong> porque como (x:xs) = [String], o &quot;x&quot; ser&#225; um [Char] (uma linha)</li></ol></div></div><div class="top"><p class="src"><a name="v:ret_Esp_Mapa" class="def">ret_Esp_Mapa</a> :: [String] -&gt; [String]</p><div class="doc"><ol><li><strong>ret_Esp_Mapa</strong> --&gt; esconde os powerUps que se encontram no mapa, isto porque estes 
     est&#227;o sempre atr&#225;s de um bloco de tijolos <strong><code>?</code></strong></li><li><strong>map (x -&gt; if (x==<code>+</code> || x==<code>!</code>) then <code>?</code> else x) (x:xs)</strong> --&gt; uma fun&#231;&#227;o que, se verificar x==<code>+</code> ou x==<code>!</code>
                                                                      substitui esse <strong>x</strong> por um <strong><code>?</code></strong></li></ol><p>A raz&#227;o pela qual tivemos que fazer um debug desta fun&#231;&#227;o, foi porque n&#243;s precisavamos visualizar
  o resultado com os powerUps vis&#237;veis para calcular as coordenadas manualmente.</p></div></div><div class="top"><p class="src"><a name="v:contagem" class="def">contagem</a> :: [Char] -&gt; Int</p><div class="doc"><p>Conta o n&#250;mero de posi&#231;&#245;es onde dever&#227;o ser colocados os valores do <strong>rnd</strong>, 
    isto para depois retirar deste os valores que j&#225; foram colocados.</p></div></div><div class="top"><p class="src"><a name="v:linhas" class="def">linhas</a> :: Int -&gt; Int -&gt; [String]</p><div class="doc"><p>Gerador do mapa com apenas as <strong>paredes (#)</strong>. Nos espa&#231;os onde ser&#225; colocado um <strong>n&#186; random</strong>,
 estar&#225; um <strong><code>r</code></strong> para mais tarde <em>substituir</em></p><ol><li><strong>linhas</strong> --&gt; cria a lista com as linhas do mapa.   </li><li><strong>(replicate (n-6) <code>r</code>)</strong> --&gt; apenas usada na primeira linha (linha 0 no Haskell) e na penultima linha (linha (n-1) no Haskell
                                 porque estas precisam de ter as linha 1 e (n-2) com dois lugares vazios no inicio e fim de cada
                                 respetiva linha, para o player conseguir se mover no inicio do jogo.</li></ol><p>A linha(n-1) &#233; a ultima linha
Ter&#225; sempre (n-1) linhas pois a linha <em>1</em> equivale &#225; posi&#231;&#227;o real <em>0</em></p><p>A raz&#227;o pela qual definimos dois casos especiais para quando <strong>n=5</strong>, foi porque este &#233; o caso mais pequeno possivel
e o m&#233;todo de cria&#231;&#227;o das linhas exige que na <em>linha1</em> e <em>linha(n-2)</em> (segunda e pen&#250;ltima respetivamente)
tenham <strong>sempre &quot;6 espa&#231;os&quot;</strong> j&#225; ocupados para podermos comparar com a dimens&#227;o, para ver quantas vezes repetimos
o caracter <strong><code>r</code></strong> (para futura substitui&#231;&#227;o por um n&#186; do <em>rnd</em>) nestas linhas. Se <strong>n=5</strong>, como <strong><em>n-6=-1</em></strong>, que
por sua vez <em>-1&lt;0</em>, a fun&#231;&#227;o iria adicionar <strong>&quot;-1&quot; vezes <code>r</code></strong> o que causa um erro.</p></div></div><div class="top"><p class="src"><a name="v:coordenadas" class="def">coordenadas</a> :: [String] -&gt; [String]</p><div class="doc"><p>Junta, com o auxilo da <strong>aux</strong> (B/F) as coordenadas de cada um dos caracteres
para isto, esta usa a fun&#231;&#227;o <strong>zip</strong> j&#225; predefinida no Haskell em cada lista de caracteres
para criar uma lista de tuplos (coordenadas de todos os caracteres)</p><pre>Fun&#231;ao que faz uma lista das linhas onde se encontram os powerups --&gt; <strong>linhaPower</strong>
Depois uma fun&#231;ao que da a lista das colunas onde os powerups se encontram --&gt; <strong>colunaPower</strong>
</pre><p><strong>contAux</strong> serve para contar o n&#250;mero de vezes que um determinado powerUp se encontra numa linha
pois pode haver mais que um powerUp na mesma linha, assim como na coluna (<strong>auxcoluna</strong>)</p></div></div><div class="top"><p class="src"><a name="v:auxB" class="def">auxB</a> :: [(Int, Int)] -&gt; [String]</p></div><div class="top"><p class="src"><a name="v:auxF" class="def">auxF</a> :: [(Int, Int)] -&gt; [String]</p></div><div class="top"><p class="src"><a name="v:linhaPower" class="def">linhaPower</a> :: Int -&gt; Char -&gt; [String] -&gt; [Int]</p></div><div class="top"><p class="src"><a name="v:contAux" class="def">contAux</a> :: Char -&gt; [Char] -&gt; Int</p></div><div class="top"><p class="src"><a name="v:colunaPower" class="def">colunaPower</a> :: Char -&gt; [String] -&gt; [Int]</p></div><div class="top"><p class="src"><a name="v:auxcoluna" class="def">auxcoluna</a> :: Int -&gt; Char -&gt; String -&gt; [Int]</p></div><div class="top"><p class="src"><a name="v:mapaDebug" class="def">mapaDebug</a> :: Int -&gt; Int -&gt; [String]</p><div class="doc"><h2 id="control.ch:mapaDebug0" class="caption collapser" onclick="toggleSection('ch:mapaDebug0')">Debug Area</h2><div id="section.ch:mapaDebug0" class="hide"><p>Esta parte do c&#243;digo daqui pra frente serve para resolver bugs existentes no c&#243;digo.</p><p>As fun&#231;oes fazem quase o mesmo que as suas correspondentes, apenas possuem uma leves altera&#231;oes:</p><ol><li><strong>mapaDebug</strong> --&gt; tem o mesmo efeito da fun&#231;&#227;o <strong>mapa</strong>, mas em vez de apresentar o resultado com os powerUps
                         escondidos, mostra onde estes est&#227;o realmente. Esta fun&#231;ao serviu para determinar se esta estava
                         a produzir as coordenadas corretas.</li></ol></div></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.16.1</p></div></body></html>